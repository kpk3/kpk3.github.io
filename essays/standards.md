---
layout: essay
type: essay
title: Those who can do, can teach.
date: 2016-12-12
labels:
  - ESLint
  - IntelliJ
---


The easiest way to ensure that one's code, in this day and age, is of the highest quality is to make it as easy to understand as possible while retaining high efficiency and utility. One example of this is the idea that if one truly understands a fact or concept, then that person would be capable of explaining/teaching it to a novice that has little to no experience regarding it. Richard Feynman had an excellent way of putting this by stating that any and all theories and concepts of physics, no matter how complex or obtuse, could be explained to a first year undergraduate if we had a firm enough understanding of them. In one instance where this wasn't the case, he announced that we simply don't understand that given topic enough.

In relation to coding, this means that "good" code, as far as I'm concerned, should be readable to someone who has only the most basic understanding of programming. To me, if someone were to say that "your code is so simple a ten year old could have written it" is a compliment. What this means is that you have the firmest understanding of how this code should operate, and most importantly appear. Coding isn't (or shouldn't be) a form of art in and of itself. Being cryptic or misdirecting doesn't earn anybody's respect, and may actually inhibit one from landing a job because an employer might think that it's more work to read than it's worth. 

My ICS 212 professor explained this readability standard to us via a brief history of coding. He told as that in the beginning, computer memory was extremely expensive and costed much more than hiring a programmer. But as hardware became more and more efficient and easier to manufacture, these prices went down and programmers' salary suddenly became a liability. Now, with hardware and software surrounding us and almost literally governing everyday life, code must follow certain safety standards in order to prevent any form of illegal activity and abuse. What this means is that in the beginning, readability wasn't an issue. Using minimal memory was. Therefore code could be as complicated as the programmer wanted so as long as it was efficient. When memory became cheap, readability became the main concern because now, company's didn't want to have to put their products entirely in the hands of a few people. If need be, they could dump their current programmers for new ones, and if the code was readable, the transition would be seamless. Today, readability is seconded only to security maintenance. Only if a piece of code is at risk of being hacked will a programmer ever feel the need to throw a curveball.

With all of this in mind even as I'm writing this essay, I remember that my product isn't for me. It's for others. As I'm learning javascript, or C, or java, or C++, or python, I like to think that in some way, I'm learning it for someone else too.
